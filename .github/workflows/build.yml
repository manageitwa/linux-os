---
name: build-ublue-custom
on:
    pull_request:
        branches:
            - main
    schedule:
        - cron: "05 10 * * *" # 10:05am UTC everyday
    push:
        branches:
            - main
        paths-ignore:
            - "**/README.md"
    workflow_dispatch:

env:
    MY_IMAGE_NAME: "${{ github.event.repository.name }}" # the name of the image produced by this build, matches repo names
    MY_IMAGE_DESC: "Fedora UBlue (Manage It customised)"
    IMAGE_REGISTRY: "ghcr.io/${{ github.repository_owner }}" # do not edit

concurrency:
    group: ${{ github.workflow }}-${{ github.ref || github.run_id }}-${{ inputs.brand_name}}-${{ inputs.stream_name }}
    cancel-in-progress: true

jobs:
    build_push:
        name: Build and push image
        runs-on: ubuntu-24.04

        permissions:
            contents: read
            packages: write
            id-token: write

        steps:
            # Checkout push-to-registry action GitHub repository
            - name: Checkout
              uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5

              # This is optional, but if you see that your builds are way too big for the runners, you can enable this by uncommenting the following lines:
            - name: Maximize build space
              uses: ublue-os/remove-unwanted-software@695eb75bc387dbcd9685a8e72d23439d8686cba6
              with:
                  remove-codeql: true

            # - name: Mount BTRFS for podman storage
            #   id: container-storage-action
            #   uses: ublue-os/container-storage-action@911baca08baf30c8654933e9e9723cb399892140

            #   # Fallback to the remove-unwanted-software-action if github doesn't allocate enough space
            #   # See: https://github.com/ublue-os/container-storage-action/pull/11
            #   continue-on-error: true
            #   with:
            #       target-dir: /var/lib/containers
            #       mount-opts: compress-force=zstd:2

            - name: Generate tags
              id: generate-tags
              shell: bash
              run: |
                  # Generate a timestamp for creating an image version history
                  TIMESTAMP="$(date +%Y%m%d)"
                  COMMIT_TAGS=()
                  BUILD_TAGS=()

                  # Have tags for tracking builds during pull request
                  SHA_SHORT="${GITHUB_SHA::7}"
                  COMMIT_TAGS+=("pr-${{ github.event.number }}")
                  COMMIT_TAGS+=("${SHA_SHORT}")

                  # Append matching timestamp tags to keep a version history
                  for TAG in "${BUILD_TAGS[@]}"; do
                      BUILD_TAGS+=("${TAG}-${TIMESTAMP}")
                  done

                  BUILD_TAGS+=("${TIMESTAMP}")
                  BUILD_TAGS+=("latest")

                  if [[ "${{ github.event_name }}" == "pull_request" ]]; then
                      echo "Generated the following commit tags: "
                      for TAG in "${COMMIT_TAGS[@]}"; do
                          echo "${TAG}"
                      done

                      alias_tags=("${COMMIT_TAGS[@]}")
                  else
                      alias_tags=("${BUILD_TAGS[@]}")
                  fi

                  echo "Generated the following build tags: "
                  for TAG in "${BUILD_TAGS[@]}"; do
                      echo "${TAG}"
                  done

                  echo "alias_tags=${alias_tags[*]}" >> $GITHUB_OUTPUT

            # Build metadata
            - name: Image Metadata
              uses: docker/metadata-action@318604b99e75e41977312d83839a89be02ca4893 # v5
              id: meta
              with:
                  images: |
                      ${{ env.MY_IMAGE_NAME }}

                  labels: |
                      io.artifacthub.package.readme-url=https://raw.githubusercontent.com/${{ github.repository }}/main/README.md
                      org.opencontainers.image.description=${{ env.MY_IMAGE_DESC }}
                      org.opencontainers.image.title=${{ env.MY_IMAGE_NAME }}

            # Build image using Buildah action
            - name: Build Image
              id: build_image
              uses: redhat-actions/buildah-build@7a95fa7ee0f02d552a32753e7414641a04307056 # v2
              with:
                  containerfiles: |
                      ./Containerfile
                  # Postfix image name with -custom to make it a little more descriptive
                  # Syntax: https://docs.github.com/en/actions/learn-github-actions/expressions#format
                  image: ${{ env.MY_IMAGE_NAME }}
                  tags: |
                      ${{ steps.generate-tags.outputs.alias_tags }}
                  labels: ${{ steps.meta.outputs.labels }}
                  oci: false

            # Workaround bug where capital letters in your GitHub username make it impossible to push to GHCR.
            # https://github.com/macbre/push-to-ghcr/issues/12
            - name: Lowercase Registry
              id: registry_case
              uses: ASzc/change-string-case-action@v6
              with:
                  string: ${{ env.IMAGE_REGISTRY }}

            - name: Login to GitHub Container Registry
              uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3
              with:
                  registry: ghcr.io
                  username: ${{ github.actor }}
                  password: ${{ secrets.GITHUB_TOKEN }}

            - name: Push Image to GHCR
              uses: redhat-actions/push-to-registry@5ed88d269cf581ea9ef6dd6806d01562096bee9c # v2
              id: push
              env:
                  REGISTRY_USER: ${{ github.actor }}
                  REGISTRY_PASSWORD: ${{ github.token }}
              with:
                  image: ${{ steps.build_image.outputs.image }}
                  tags: ${{ steps.build_image.outputs.tags }}
                  registry: ${{ steps.registry_case.outputs.lowercase }}
                  username: ${{ env.REGISTRY_USER }}
                  password: ${{ env.REGISTRY_PASSWORD }}
                  extra-args: |
                      --compression-format=zstd

            # This section is optional and only needs to be enabled if you plan on distributing
            # your project for others to consume. You will need to create a public and private key
            # using Cosign and save the private key as a repository secret in Github for this workflow
            # to consume. For more details, review the image signing section of the README.

            # Sign container
            - name: Install Cosign
              uses: sigstore/cosign-installer@d7543c93d881b35a8faa02e8e3605f69b7a1ce62 # v3.10.0
              if: github.event_name != 'pull_request'

            - name: Sign container image
              if: github.event_name != 'pull_request'
              run: |
                  cosign sign -y --key env://COSIGN_PRIVATE_KEY ${{ steps.registry_case.outputs.lowercase }}/${{ steps.build_image.outputs.image }}@${TAGS}
              env:
                  TAGS: ${{ steps.push.outputs.digest }}
                  COSIGN_EXPERIMENTAL: false
                  COSIGN_PRIVATE_KEY: ${{ secrets.SIGNING_SECRET }}
